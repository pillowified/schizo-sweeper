<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schizo Sweeper</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="cursor-glow"></div>
    <div class="bg-stars"></div>
    <div id="settings-menu-box">
        <div>
            <h2 class="unselectable" style="text-shadow: 0.2rem 0.2rem rgba(0, 0, 0, 0.1);">Settings</h2>
            <div id="settings-menu">
                <div id="settings-page">
                    <h3 id="theme-button" class="unselectable">Themes</h3>
                    <h3 id="mod-button" class="unselectable">Mods</h3>
                </div>
                <div id="themes-container">
                    <h3 class="unselectable">Themes</h3>
                    <div id="themes">
                        <div id="pastel-bg"></div>
                        <div id="al-bg"></div>
                        <div id="strawberry-bg"></div>
                        <div id="arctic-bg"></div>
                        <div id="space-bg"></div>
                        <div id="peachy-bg"></div>
                        <div id="midnight-bg"></div>
                        <div id="darksky-bg"></div>
                        <div id="dream-bg"></div>
                    </div>
                </div>
                <div id="mods-container" style="width: 100%; height: 100%;">
                    <h3 class="unselectable">Mods</h3>
                    <div id="mods">
                        <div>
                            <label for="t44t-holder" class="unselectable">t44t Mode</label>
                            <label class="switch unselectable" id="t44t-holder">
                                <input type="checkbox" id="t44t">
                                <span class="slider round"></span>
                            </label>
                        </div>
                        <div>
                            <label for="gold-holder" class="unselectable">Golden Mode</label>
                            <label class="switch unselectable" id="gold-holder">
                                <input type="checkbox" id="gold">
                                <span class="slider round"></span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" style="position: relative; padding: 8px;" id="settings-cog" class="unselectable">
            <path fill="currentColor" d="m9.25 22l-.4-3.2q-.325-.125-.612-.3t-.563-.375L4.7 19.375l-2.75-4.75l2.575-1.95Q4.5 12.5 4.5 12.338v-.675q0-.163.025-.338L1.95 9.375l2.75-4.75l2.975 1.25q.275-.2.575-.375t.6-.3l.4-3.2h5.5l.4 3.2q.325.125.613.3t.562.375l2.975-1.25l2.75 4.75l-2.575 1.95q.025.175.025.338v.674q0 .163-.05.338l2.575 1.95l-2.75 4.75l-2.95-1.25q-.275.2-.575.375t-.6.3l-.4 3.2zm2.8-6.5q1.45 0 2.475-1.025T15.55 12t-1.025-2.475T12.05 8.5q-1.475 0-2.488 1.025T8.55 12t1.013 2.475T12.05 15.5" />
        </svg>
    </div>
    <button style="position: fixed; display: none;" onclick="darkmode()">
        Toggle Dark Mode
    </button>
    <div id="main">
        <main>
            <h1 class="unselectable" id="title">Schizo Sweeper</h1>
            <div id="selection">
                <div id="left">
                    <h2 style="text-align: center; text-shadow: 0.2rem 0.2rem rgba(0, 0, 0, 0.1);" class="unselectable">Difficulty Selection</h2>
                    <div id="preset">
                        <div id="difficulties">
                            <div id="select-box"></div>    
                            <button id="easy" class="dSelector">Easy</button>
                            <div class="divider"></div>
                            <button id="medium" class="dSelector">Medium</button>
                            <div class="divider"></div>
                            <button id="hard" class="dSelector">Hard</button>
                            <div class="divider"></div>
                            <button id="custom" class="dSelector">Custom</button>
                        </div>
                        <h3 id="d-data">
                            placeholder<br>
                            lorem<br>
                            ipsum
                        </h3>
                        <button id="start">Start</button>
                    </div>
                </div>
                <div id="right">
                    <h2 style="text-align: center; text-shadow: 0.2rem 0.2rem rgba(0, 0, 0, 0.1);" class="unselectable">Statistics</h2>
                    <div id="stat-box">

                    </div>
                </div>
            </div>
        </main>
        <div id="game" class="unselectable">
            <div id="outer-field" class="unselectable">
                <div id="hud" class="unselectable">
                    <div id="flags" class="unselectable"></div>
                </div>
                <div id="game-field" class="unselectable"></div>
                <div id="vignette" class="unselectable">
                    <div id="containing-thing">
                        <h1 id="condition"></h1>
                        <img src="stare-dont-blink.gif" alt="ye" id="ye">
                        <img src="KanyeWest.png" alt="ye2" id="ye2">
                        <img src="goldgoldgold.gif" alt="ohnee" id="ohne">
                        <div id="buttons">
                            <input id="retry" type="button" value="Retry" onclick="retry()">
                            <input id="back" type="button" value="Back" onclick="if (!cooldown) location.reload();">
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="version" class="unselectable">Schizo Sweeper ver. 0.15.30 by t0rtur</div>
    </div>


    <script>
        const bgstars = document.body.querySelector(".bg-stars");

        function createStar() {
            const star = document.createElement("div");
            star.classList.add("star");
            bgstars.appendChild(star);

            star.style.left = `${Math.random() * 100}vw`;
            star.style.top = `${Math.random() * 100}vh`;
            star.style.width = star.style.height = `${Math.random() * 2 + 1}px`;
            star.style.opacity = `${Math.random() * 0.5 + 0.5}`;
            star.style.animationDelay = `${Math.random() * 2}s`;

            const dx = (Math.random() - 0.5) * 0.05;
            const dy = (Math.random() - 0.5) * 0.05;

            let x = parseFloat(star.style.left);
            let y = parseFloat(star.style.top);

            function animate() {
                x += dx;
                y += dy;

                if (x < 0 || x > 100 || y < 0 || y > 100) {
                    x = Math.random() * 100;
                    y = Math.random() * 100;
                }

                star.style.left = `${x}vw`;
                star.style.top = `${y}vh`;

                requestAnimationFrame(animate);
            }

            animate();
        }

        document.addEventListener("DOMContentLoaded", () => {
            for (let i = 0; i < 100; i++) {
                createStar();
            }
        });

        const title = document.body.querySelector("#title");
        title.classList.add("fader");
        
        function randomFloaty() {
            const x = (Math.random() - 0.5) * 40;
            const y = (Math.random() - 0.5) * 40;
            const rotation = (Math.random() - 0.5) * 10;

            title.style.transform = `translate(${x}px, ${y}px) rotate(${rotation}deg)`;
        }

        setInterval(randomFloaty, 2000)

        const left = document.body.querySelector("#left");
        const right = document.body.querySelector("#right");

        function randomFloaties() {
            let x = (Math.random() - 0.5) * 20;
            let y = (Math.random() - 0.5) * 20;
            let rotation = (Math.random() - 0.5) * 5;

            left.style.transform = `translate(${x}px, ${y}px) rotate(${rotation}deg)`;

            x = (Math.random() - 0.5) * 20;
            y = (Math.random() - 0.5) * 20;
            rotation = (Math.random() - 0.5) * 5;

            right.style.transform = `translate(${x}px, ${y}px) rotate(${rotation}deg)`;
        }
        setTimeout(() => {
            randomFloaties();
        }, 100);
        setInterval(randomFloaties, 4000)

        const main = document.body.querySelector("main");

        setTimeout(() => {
            main.querySelectorAll("div").forEach(element => {
                element.classList.add("faded");
            });
        }, 1000);

        const cursorGlow = document.querySelector('.cursor-glow');

        document.addEventListener('mousemove', e => {
            cursorGlow.style.left = `${e.clientX}px`;
            cursorGlow.style.top = `${e.clientY}px`;
        });

        let revealed = false;
        const settingscog = document.body.querySelector("#settings-cog");
        const settingsmenu = document.body.querySelector("#settings-menu");
        const settingsmenubox = document.body.querySelector("#settings-menu-box");

        const settingspage = document.body.querySelector("#settings-page");
        const themescontainer = document.body.querySelector("#themes-container");
        const modscontainer = document.body.querySelector("#mods-container");
        const mods = document.body.querySelector("#mods");
        let modArray = [];

        if (localStorage.getItem('mods') != null) {
            modArray = JSON.parse(localStorage.getItem('mods'));
            document.querySelector("#t44t").checked = modArray[0];
            document.querySelector("#gold").checked = modArray[1];
        } else {
            modArray = [false, false];
            localStorage.setItem('mods', JSON.stringify(modArray));
        }

        mods.addEventListener("change", function (event) {
            if (event.target.tagName === "INPUT" && event.target.type === "checkbox") {
                const input = event.target;
                switch (input.id) {
                    case "t44t":
                        modArray[0] = input.checked;
                        break;
                    case "gold":
                        modArray[1] = input.checked;
                        break;
                }
                localStorage.setItem('mods', JSON.stringify(modArray));
            }
        });

        settingscog.addEventListener("click", () => {
            if (settingsmenubox.classList.contains("settingsMover")) {
                revealed = false;
                settingsmenubox.className = "";
                settingsmenu.className = "";
                themescontainer.className = "";
                modscontainer.className = "";
                settingscog.classList.remove("settingsMover-themes"); 
                setTimeout(() => {
                    settingspage.className = "";
                    settingspage.style.display = "flex";
                    themescontainer.style.display = "none";
                    modscontainer.style.display = "none";
                }, 300);
            } else {
                settingsmenubox.classList.add("settingsMover");
                revealed = true;
            }
        });

        const modbutton = document.getElementById("mod-button");

        settingspage.querySelectorAll("h3").forEach(element => {
            element.addEventListener("click", e => {
                switch (e.target.id) {
                    case "theme-button":
                        settingspage.classList.add("hider");
                        themescontainer.style.display = "block";
                        setTimeout(() => {
                            if (revealed == true) {
                                settingscog.classList.add("settingsMover-themes");
                                settingsmenu.className = "themes-page";
                                settingspage.style.display = "none";
                                themescontainer.classList.add("fadein");
                            }
                        }, 500);
                        break;
                    case "mod-button":
                        settingspage.classList.add("hider")
                        modscontainer.style.display = "block";
                         setTimeout(() => {
                            if (revealed == true) {
                                settingscog.classList.add("settingsMover-themes");
                                settingsmenu.className = "themes-page";
                                settingspage.style.display = "none";
                                modscontainer.classList.add("fadein");
                            }
                        }, 500);
                        break;
                    default:
                        break;
                }
            });
        });


        const sBox = document.body.querySelector("#stat-box");
        const dSelection = document.body.querySelector("#select-box");
        const dData = document.body.querySelector("#d-data");
        const dSelectors = document.body.querySelectorAll(".dSelector");
        let selectedD = 1;
        dSelection.style.left = "0%";
        dData.innerHTML = "<div><div>Columns: </div><div>10</div></div><div><div>Rows: </div><div>8</div></div><div><div>Mines: </div><div>10</div></div>";
        sBox.innerHTML = "yo1";
        dSelectors.forEach(element => {
            element.addEventListener('click', difficultyChooser);
        });

        function difficultyChooser(e) {
            switch (e.target.innerHTML) {
                    case "Easy":
                        selectedD = 1;
                        dSelection.style.left = "0%";
                        dData.innerHTML = "<div><div>Columns: </div><div>10</div></div><div><div>Rows: </div><div>8</div></div><div><div>Mines: </div><div>10</div></div>";
                        sBox.innerHTML = "<div><h3>Games Played:</h3><div>0</div></div>";
                        break;
                    case "Medium":
                        selectedD = 2;
                        dSelection.style.left = "25%";
                        dData.innerHTML = "<div><div>Columns: </div><div>18</div></div><div><div>Rows: </div><div>14</div></div><div><div>Mines: </div><div>40</div></div>";
                        sBox.innerHTML = "yo2";
                        break;
                    case "Hard":
                        selectedD = 3;
                        dSelection.style.left = "50%";
                        dData.innerHTML = "<div><div>Columns: </div><div>24</div></div><div><div>Rows: </div><div>20</div></div><div><div>Mines: </div><div>99</div></div>";
                        sBox.innerHTML = "yo3";
                        break;
                    case "Custom":
                        selectedD = 0;
                        dSelection.style.left = "75%";
                        dData.innerHTML = "<div><h4 id='ad-info'>* max: 40 col, 25 row, 999 mine</h4>Columns: <input type='number' id='cc' class='cinput'></div><div>Rows: <input type='number' id='rc' class='cinput'></div><div>Mines: <input type='number' id='mc' class='cinput'></div>";
                        sBox.innerHTML = "yo0";
                        break;
            }
            localStorage.setItem('difficulty', selectedD);
        }

        if (localStorage.getItem('difficulty') != null) {
            selectedD = parseInt(localStorage.getItem('difficulty'));
            switch (selectedD) {
                case 1:
                    dSelection.style.left = "0%";
                    dData.innerHTML = "<div><div>Columns: </div><div>10</div></div><div><div>Rows: </div><div>8</div></div><div><div>Mines: </div><div>10</div></div>";
                    sBox.innerHTML = "<div><h3>Games Played:</h3><div>0</div></div>";
                    break;
                case 2:
                    dSelection.style.left = "25%";
                    dData.innerHTML = "<div><div>Columns: </div><div>18</div></div><div><div>Rows: </div><div>14</div></div><div><div>Mines: </div><div>40</div></div>";
                    sBox.innerHTML = "yo2";
                    break;
                case 3:
                    dSelection.style.left = "50%";
                    dData.innerHTML = "<div><div>Columns: </div><div>24</div></div><div><div>Rows: </div><div>20</div></div><div><div>Mines: </div><div>99</div></div>";
                    sBox.innerHTML = "yo3";
                    break;
                case 0:
                    dSelection.style.left = "75%";
                    dData.innerHTML = "<div><h4 id='ad-info'>* max: 40 col, 25 row, 999 mine</h4>Columns: <input type='number' id='cc' class='cinput'></div><div>Rows: <input type='number' id='rc' class='cinput'></div><div>Mines: <input type='number' id='mc' class='cinput'></div>";
                    sBox.innerHTML = "yo0";
                    break;
            }
        } else {
            localStorage.setItem('difficulty', selectedD);
        }
        const dValues = {
            easy: {
                columns: 10,
                rows: 8,
                mines: 10
            },
            medium: {
                columns: 18,
                rows: 14,
                mines: 40
            },
            hard: {
                columns: 24,
                rows: 20,
                mines: 99
            },
            custom: {
                columns: [2, 40],
                rows: [2, 25],
                mines: [1, 999]
            }
        }

        let records = [
            [

            ],
            [],
            [],
            []
        ];
        localStorage.setItem("records", records);

        if (localStorage.getItem('theme') != null) {
            document.body.classList.add(localStorage.getItem('theme'));
        } else {
            document.body.classList.add("darksky-bg");
            localStorage.setItem('theme', 'darksky-bg');
        }

        const themes = document.querySelector("#themes");
        themes.querySelectorAll("div").forEach(element => {
            element.addEventListener("click", e => {
                document.body.className = e.target.id;
                localStorage.setItem('theme', e.target.id);
            })
        });

        const debugMode = false;
        const fullSchizo = false;
        const game = document.body.querySelector("#game");
        let started = false;
        game.style.display = "hidden";

        const start = document.body.querySelector("#start");
        start.addEventListener("click", starter);

        function starter () {
            if (started == false) {
                started = true;
                let start = null;

                modbutton.classList.add("darkened");
                modscontainer.querySelectorAll("*").forEach(element => {
                    element.classList.add("darkened");
                });    
                document.querySelector("#mods").querySelectorAll("input").forEach(element => {
                    element.disabled = true;
                });

                function fadeOut(timestamp) {
                if (!start) start = timestamp;
                let progress = (timestamp - start);
                let opacity = Math.max(1 - progress / 1000, 0);

                main.style.opacity = opacity;

                if (opacity > 0) {
                    requestAnimationFrame(fadeOut);
                } else {
                    main.style.display = "none";
                    game.style.display = "flex";
                    setTimeout(() => {
                        game.classList.add("fader");
                        generateField();
                    }, 100);
                }
            }

                requestAnimationFrame(fadeOut);   
            }
        }

        const gamefield = document.body.querySelector("#game-field");
        let levels = ['easy', 'medium', 'hard'];
        const minValues = [dValues.custom.columns[0], dValues.custom.rows[0], dValues.custom.mines[0]];
        const maxValues = [dValues.custom.columns[1], dValues.custom.rows[1], dValues.custom.mines[1]];
        let tiles = []

        const baseWidth = 1920;
        const scale = window.innerWidth / baseWidth;

        const rawSize = 30 * scale;
        const tileSize = Math.min(Math.max(rawSize, 25), 50) + "px"; 

        function generateField () {
            const cinputs = document.body.querySelectorAll(".cinput");
            if  (selectedD > 0) {
                gamefield.style.gridTemplateColumns = `repeat(${dValues[levels[selectedD - 1]].columns}, ${tileSize}`;
                gamefield.style.gridTemplateRows = `repeat(${dValues[levels[selectedD - 1]].rows}, ${tileSize}`;
            } else {
                for (let index = 0; index < 3; index++) {
                    if (cinputs[index].value < minValues[index]) {
                        cinputs[index].value = minValues[index];
                    }
                    if (cinputs[index].value > maxValues[index]) {
                        cinputs[index].value = maxValues[index];
                    }       
                }
                if (cinputs[2].value >= cinputs[0].value * cinputs[1].value) {
                    cinputs[2].value = (cinputs[0].value * cinputs[1].value) - 1;
                }
                gamefield.style.gridTemplateColumns = `repeat(${cinputs[0].value}, ${tileSize}`;
                gamefield.style.gridTemplateRows = `repeat(${cinputs[1].value}, ${tileSize}`;
            }

            window.addEventListener("resize", () => {
                    const baseWidth = 1920;
                    const scale = window.innerWidth / baseWidth;

                    const rawSize = 30 * scale;
                    const tileSize = Math.min(Math.max(rawSize, 25), 50) + "px"; 

                    if (selectedD > 0) {
                        gamefield.style.gridTemplateColumns = `repeat(${dValues[levels[selectedD - 1]].columns}, ${tileSize}`;
                        gamefield.style.gridTemplateRows = `repeat(${dValues[levels[selectedD - 1]].rows}, ${tileSize}`;
                    } else {
                        gamefield.style.gridTemplateColumns = `repeat(${cinputs[0].value}, ${tileSize}`;
                        gamefield.style.gridTemplateRows = `repeat(${cinputs[1].value}, ${tileSize}`;
                    }
                });

            if (selectedD > 0) {
                for (let row = 0; row < dValues[levels[selectedD - 1]].rows; row++) {
                    for (let col = 0; col < dValues[levels[selectedD - 1]].columns; col++) {       
                        const tile = {
                            id: `${row}-${col}`,
                            isFlagged: false,
                            isRevealed: false,
                            isMine: false,
                            neighbors: [],
                            timeoutId: null
                        };
            
                        tiles.push(tile);

                        const tileElement = document.createElement('div');
                        tileElement.classList.add('tile');
                        tileElement.classList.add('unselectable');
                        tileElement.style.textAlign = "center";
                        tileElement.dataset.id = tile.id;

                        if ((row + col) % 2 === 0) {
                            tileElement.classList.add('light');
                        } else {
                            tileElement.classList.add('dark');
                        }

                        gamefield.appendChild(tileElement);
                    }
                }
            } else {
                for (let row = 0; row < cinputs[1].value; row++) {
                    for (let col = 0; col < cinputs[0].value; col++) {       
                        const tile = {
                            id: `${row}-${col}`,
                            isFlagged: false,
                            isRevealed: false,
                            isMine: false,
                            neighbors: [],
                            minesAround: null
                        };
            
                        tiles.push(tile);

                        const tileElement = document.createElement('div');
                        tileElement.classList.add('tile');
                        tileElement.classList.add('unselectable');
                        tileElement.style.textAlign = "center";
                        tileElement.dataset.id = tile.id;

                        if ((row + col) % 2 === 0) {
                            tileElement.classList.add('light');
                        } else {
                            tileElement.classList.add('dark');
                        }

                        gamefield.appendChild(tileElement);
                    }
                }
            }
            placeMines();
        }

        let remainingMines;
        let flagCount;
        const flags = document.getElementById("flags");

        function placeMines() {
            const cinputs = document.body.querySelectorAll(".cinput");

            if (selectedD > 0) {
                remainingMines = dValues[levels[selectedD - 1]].mines;
                flagCount = remainingMines;
            } else {
                remainingMines = cinputs[2].value;
                flagCount = remainingMines;
            }

            flags.innerText = "🚩 : " + flagCount;

            while (remainingMines > 0) {
                const randomIndex = Math.floor(Math.random() * tiles.length);
                const tile = tiles[randomIndex];

                if (!tile.isMine) {
                    tile.isMine = true;
                    remainingMines--;
                    }
            }

            while (remainingMines > 0) {
                const randomIndex = Math.floor(Math.random() * tiles.length);
                const tile = tiles[randomIndex];

                if (!tile.isMine) {
                    tile.isMine = true;
                     remainingMines--;
                }
            }
            addNeighbors();
        }

        function addNeighbors() {
            tiles.forEach(tile => {
                const [row, col] = tile.id.split('-').map(Number);

                const neighbors = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1],            [0, 1],
                    [1, -1], [1, 0], [1, 1]
                ];

                if (selectedD > 0) {
                    neighbors.forEach(([r, c]) => {
                    if (row + r >= 0 && row + r < dValues[levels[selectedD - 1]].rows && col + c >= 0 && col + c < dValues[levels[selectedD - 1]].columns) {
                        const neighborTile = tiles.find(t => t.id === `${row + r}-${col + c}`);
                        tile.neighbors.push(neighborTile);
                    }
                })
                } else {
                    const cinputs = document.body.querySelectorAll(".cinput");
                    neighbors.forEach(([r, c]) => {
                    if (row + r >= 0 && row + r < cinputs[1].value && col + c >= 0 && col + c < cinputs[0].value) {
                        const neighborTile = tiles.find(t => t.id === `${row + r}-${col + c}`);
                        tile.neighbors.push(neighborTile);
                    }
                })
                }

                initializeBoard()
                countNeighborMines();
            });
        }

        function countNeighborMines() {
            tiles.forEach(tile => {
                tile.minesAround = tile.neighbors.filter(neighbor => neighbor && neighbor.isMine).length;
            });
        }

        function initializeBoard() {
            tiles.forEach(tile => {
                const tileElement = document.querySelector(`[data-id="${tile.id}"]`);
                if (!tile.isMine && tileElement.classList.contains('mine')) {
                    tileElement.textContent = '';
                    tileElement.classList.remove('mine');
                }
                if (debugMode && tile.isMine) {
                    tileElement.classList.add('mine');
                    if (tile.isFlagged) {
                        tileElement.textContent = '🚩';
                    } else {
                        tileElement.textContent = '💣';
                    }
                }
            });
        }

        let minesShuffled = false;
        let firstClick = true;
        let extend = false;
        let timer;
        const tileTimers = new Map();
        const goldTimer = new Map();

        const gold = document.querySelector("#gold");
        let golded = false;

        function runTimer(tilesToShow) {
            tileTimers.forEach(timer => clearTimeout(timer));
            tileTimers.clear();
            tilesToShow.forEach(t => {
                const tElement = document.querySelector(`[data-id="${t.id}"]`);
                if (!tElement) return;

                if (tileTimers.has(t.id)) {
                    clearTimeout(tileTimers.get(t.id));
                }

                tElement.textContent = t.minesAround > 0 ? t.minesAround : '';

                const timeout = setTimeout(() => {
                    if (!t.isMine) {
                        tElement.textContent = '';
                    }
                    tileTimers.delete(t.id); 
                }, 1500);

                tileTimers.set(t.id, timeout);
            });
        }

        let goldPlaced = false;

        function goldify() {
            goldTimer.forEach(timer => clearTimeout(timer));
            goldTimer.clear();

            const filteredTiles = tiles.filter(tile => tile.isRevealed);
            if (filteredTiles.length === 0) return;

            const totalSafeTiles = tiles.filter(t => !t.isMine).length;
            const unrevealedSafeTiles = tiles.filter(t => !t.isMine && !t.isRevealed).length;

            const baseDelay = 7500;
            const minDelay = 750;

            const progress = 1 - (unrevealedSafeTiles / totalSafeTiles);
            const delay = minDelay + ((baseDelay - minDelay) * progress);


            const minGoldTiles = 1;
            const maxGoldTiles = Math.min(10, Math.ceil(filteredTiles.length * 0.05));
            const count = Math.floor(Math.random() * (maxGoldTiles - minGoldTiles + 1)) + minGoldTiles;

            const chosenTiles = [];
            while (chosenTiles.length < count) {
                const tile = filteredTiles[Math.floor(Math.random() * filteredTiles.length)];
                if (!chosenTiles.includes(tile)) {
                    chosenTiles.push(tile);
                }
            }

            chosenTiles.forEach(tile => {
                const tElement = document.querySelector(`[data-id="${tile.id}"]`);
                if (!tElement) return;

                tElement.classList.add("golden");
                goldPlaced = true;

                if (goldTimer.has(tile.id)) {
                    clearTimeout(goldTimer.get(tile.id));
                }

                const timeout = setTimeout(() => {
                    const tileElements = document.querySelectorAll('[data-id]');
                    if (Array.from(tileElements).every(tile => !tile.classList.contains('golden'))) {
                        goldPlaced = false;
                    };

                    if (goldPlaced && started) {
                        tElement.classList.remove("golden");
                        goldTimer.delete(tile.id);

                        if (!golded) {
                            golded = true;
                            started = false;
                            endSequence(false);
                        }
                    }
                }, delay);
                goldTimer.set(tile.id, timeout);
            });
        }



        const vignette = document.getElementById("vignette");

        function checkWinCondition() {
            return tiles.every(tile => tile.isMine || tile.isRevealed);
        }

        function revealTile(tileElement, tile, key, isRecursing = false) {
            clearTimeout(timer);
            if (!fullSchizo) {
                key = true;
            }

            if (tile.isRevealed || tile.isFlagged) return;

            if (firstClick) {
                firstClick = false;

                if (tile.isMine) {
                    tile.isMine = false;
                    const safeTile = tiles.find(t => !t.isMine && !t.isRevealed && !t.isFlagged && t !== tile);
                    if (safeTile) {
                        safeTile.isMine = true;
                    }

                    initializeBoard();
                    countNeighborMines();

                    tile.minesAround = tile.neighbors.filter(neighbor => neighbor && neighbor.isMine).length;
                }
            }


            tile.isRevealed = true;
            tileElement.classList.add('revealed');
            tileElement.textContent = '';

            if (tile.isMine) {
                tileElement.classList.add('mine');
                tileElement.textContent = '💣';
                started = false;
                endSequence(false);
                return;
            }

            if (tileElement.classList.contains("golden")) {
                tileElement.classList.remove("golden");
            }

            if (checkWinCondition()) {
                started = false;
                endSequence(true);
                return;
            }

            tiles.forEach(t => {
                if (t.isRevealed && !t.isMine && !t.isFlagged) {
                    const tElement = document.querySelector(`[data-id="${t.id}"]`);
                    tElement.textContent = "";
                }
            });

            if (!minesShuffled && !isRecursing) {
                minesShuffled = true;
                shuffleMines();
            }

            if (tile.minesAround === 0) {
                tile.neighbors.forEach(neighbor => {
                    const neighborElement = document.querySelector(`[data-id="${neighbor.id}"]`);
                    if (neighbor && !neighbor.isRevealed && !neighbor.isFlagged && !neighbor.isMine && !neighborElement.classList.contains("golden")) {
                        revealTile(neighborElement, neighbor, false, true);
                    }
                });
            }


            if (key) {
                const tilesToShow = new Set();

                [tile, ...tile.neighbors.filter(n => n)].forEach(t => {
                    if (t && t.isRevealed && !t.isMine) {
                        tilesToShow.add(t);
                    }
                });

                tiles.forEach(t => {
                    if (t.isRevealed && !t.isMine) {
                        const hasUnrevealedNeighbor = t.neighbors.some(n => n && !n.isRevealed);
                        if (hasUnrevealedNeighbor) {
                            tilesToShow.add(t);
                        }
                    }
                });

                if (gold.checked) {
                    if (!goldPlaced) {
                        if (!isRecursing) {
                            if (Math.random() < 0.1) {
                                goldify();
                            }
                        }
                    }
                }

                runTimer(tilesToShow);
            }
        }

        function shuffleMines() {
            const remainingTiles = tiles.filter(tile => {
                const el = document.querySelector(`[data-id="${tile.id}"]`);
                return !tile.isRevealed && !tile.isFlagged && !(el && el.classList.contains("golden"));
            });

            const minesToShuffle = remainingTiles.filter(tile => tile.isMine);

            remainingTiles.forEach(tile => tile.isMine = false);

            for (let i = remainingTiles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [remainingTiles[i], remainingTiles[j]] = [remainingTiles[j], remainingTiles[i]];
            }

            for (let i = 0; i < minesToShuffle.length; i++) {
                remainingTiles[i].isMine = true;
            }

            initializeBoard();
            countNeighborMines();
        }

        const textCondition = document.getElementById("condition");

        let cooldown = false;
        
        function endSequence (condition) {
            cooldown = true;
            setTimeout(() => {
                cooldown = false;
            }, 500);
            vignette.classList.add("fadein");
            modbutton.classList.remove("darkened");
            modscontainer.querySelectorAll("*").forEach(element => {
                    element.classList.remove("darkened");
                });   
            document.querySelector("#mods").querySelectorAll("input").forEach(element => {
                element.disabled = false;
            });

            setTimeout(() => {
                const totalSafeTiles = tiles.filter(t => !t.isMine).length;
                const unrevealedSafeTiles = tiles.filter(t => !t.isMine && !t.isRevealed).length;

                if (condition) {
                    textCondition.innerText = "You WIN!";
                } else {
                    textCondition.innerText = "You LOST!";

                    if (golded) {
                        golded = false;
                        const ohne = document.getElementById("ohne");
                        ohne.style.display = "block";
                    }
                    else if (unrevealedSafeTiles === 1) {
                        const ye2 = document.getElementById("ye2");
                        ye2.style.display = "block";
                    } else if (unrevealedSafeTiles <= totalSafeTiles * 0.10) {
                        const ye = document.getElementById("ye");
                        ye.style.display = "block";
                    }
                }
            }, 50);
        }

        function retry() {
            if (!cooldown) {
                vignette.classList.remove("fadein");
                modbutton.classList.add("darkened");
                modscontainer.querySelectorAll("*").forEach(element => {
                    element.classList.add("darkened");
                });   
                document.querySelector("#mods").querySelectorAll("input").forEach(element => {
                    element.disabled = true;
                });
                const ohne = document.getElementById("ohne")
                        ohne.style.display = "none";
                const ye = document.getElementById("ye")
                        ye.style.display = "none";
                const ye2 = document.getElementById("ye2")
                        ye2.style.display = "none";
                tiles.forEach(tile => {
                    tile.isFlagged = false;
                    tile.isRevealed = false;
                    tile.isMine = false;
                    tile.neighbors = [];
                    tile.minesAround = null;
                })
                const divs = document.getElementById("game-field");
                divs.querySelectorAll("div").forEach(div => {
                    div.classList.remove("revealed", "mine", "flagged", "golden");
                    div.textContent = "";
                });
    
                tileTimers.forEach(timer => clearTimeout(timer));
                tileTimers.clear();
                goldTimer.forEach(timer => clearTimeout(timer));
                goldTimer.clear();
                tiles.forEach(t => {
                const tElement = document.querySelector(`[data-id="${t.id}"]`);
                if (!tElement) return;
    
                if (tileTimers.has(t.id)) {
                    clearTimeout(tileTimers.get(t.id));
                }
    
                tElement.textContent = '';});
                    
                golded = false;
                goldPlaced = false;
                started = true;
                firstClick = true;
    
                placeMines();
            }
        }

        gamefield.addEventListener('click', function (event) {
            if (started) {
                if (event.target.classList.contains('tile')) {
                    if (!suppressNextReveal) {
                        const clickedTileId = event.target.dataset.id;
                    const clickedTile = tiles.find(t => t.id === clickedTileId);

                    if (event.target.classList.contains("golden")) {
                        event.target.classList.remove("golden")
                    }

                    if (clickedTile.isRevealed || clickedTile.isFlagged) return;

                    minesShuffled = false;

                    revealTile(event.target, clickedTile, true);
                    }
                }
            }
        });

        gamefield.addEventListener('contextmenu', function (event) {
            event.preventDefault();
            if (event.pointerType === 'touch' || event.sourceCapabilities?.firesTouchEvents) {
        event.preventDefault();
        return;
    }
            if (started) {
                if (event.target.classList.contains('tile')) {

                    const clickedTileId = event.target.dataset.id;
                    const clickedTile = tiles.find(t => t.id === clickedTileId);

                    if (!clickedTile.isRevealed) {

                        if (clickedTile.isFlagged) {
                            clickedTile.isFlagged = !clickedTile.isFlagged;
                            event.target.textContent = "";
                            event.target.classList.toggle('flagged');
                            initializeBoard()
                            flagCount++;
                        } else {
                            if (flagCount > 0) {
                                clickedTile.isFlagged = !clickedTile.isFlagged;
                                event.target.textContent = "🚩";
                                event.target.classList.toggle('flagged');
                                flagCount--;
                            }
                        }
                        flags.innerText = "🚩 : " + flagCount;
                    }
                }
            }
        });

        let starteer = 0;
        let holdTimer = null;
        let suppressNextReveal = false;
        const holdDuration = 150;
        let justFlagged = false;


        let startX = 0;
let startY = 0;
const moveThreshold = 10;

gamefield.addEventListener("touchstart", function (event) {
    const target = event.target;
    if (!target.classList.contains("tile")) return;
    
    if (event.touches.length > 1) return;

    starteer = Date.now();
    suppressNextReveal = false;

    const touch = event.touches[0];
    startX = touch.clientX;
    startY = touch.clientY;

    holdTimer = setTimeout(() => {
        event.preventDefault();
        const clickedTileId = target.dataset.id;
        const clickedTile = tiles.find(t => t.id === clickedTileId);

        if (!clickedTile.isRevealed) {
            if (clickedTile.isFlagged) {
                clickedTile.isFlagged = false;
                target.textContent = "";
                target.classList.remove('flagged');
                initializeBoard();
                flagCount++;
                suppressNextReveal = true;
            } else {
                if (flagCount > 0) {
                    clickedTile.isFlagged = true;
                    target.textContent = "🚩";
                    target.classList.add('flagged');
                    flagCount--;
                    suppressNextReveal = true;
                }
            }
            flags.innerText = "🚩 : " + flagCount;
            justFlagged = true;
        }
        holdTimer = null;

    }, holdDuration);
});

gamefield.addEventListener("touchmove", function (event) {
    if (!holdTimer) return;

    const touch = event.touches[0];
    const deltaX = Math.abs(touch.clientX - startX);
    const deltaY = Math.abs(touch.clientY - startY);

    if (deltaX > moveThreshold || deltaY > moveThreshold) {
        clearTimeout(holdTimer);
        holdTimer = null;
    }
});

        gamefield.addEventListener("touchend", function (event) {

            const target = event.target;
            if (!target.classList.contains("tile")) return;

            const clickedTileId = target.dataset.id;
            const clickedTile = tiles.find(t => t.id === clickedTileId);

            let end = Date.now();

            if (holdTimer) {
        clearTimeout(holdTimer);
        holdTimer = null;

        if (justFlagged) {
            justFlagged = false;
            return;
        }

        if (suppressNextReveal) {
            setTimeout(() => {
                  suppressNextReveal = false;
                }, 250);
        }

        const target = event.target;
        if (!target.classList.contains("tile")) return;

        const clickedTileId = target.dataset.id;
        const clickedTile = tiles.find(t => t.id === clickedTileId);

        if (event.target.classList.contains("golden")) {
                        event.target.classList.remove("golden")
                    }

        if (clickedTile.isRevealed || clickedTile.isFlagged) return;

                    minesShuffled = false;

                    revealTile(event.target, clickedTile, true);
        }
        });

        gamefield.addEventListener("touchcancel", function () {
            if (holdTimer) {
        clearTimeout(holdTimer);
        holdTimer = null;
    }
});
        

    </script>
</body>
</html>
